.NM as80 Intel 8080 Assembler Internals
.FU
.hc
as80 reads Intel 8080 assembler source from one or more files, or STDIN,
and writes a relocatable object file suitable for input to ld.
It operates in two passes:
1) source code is read, the symbol table is constructed, and object code
is written with relocation information to two temporary files, one for
the text section and one for the data section;
2) the intermediate files are read one at a time, relocation is performed
where possible and encoded for output otherwise, and the object file is
constructed by writing the code and relocation portions in parallel.
.LP
Source code is organized into five files:
data structures and manifest constants in
a header file "a.h", the main control code in "amain.c",
token, expression, and address mode constructors in "amake.c",
identifier definition and code production in "asm.c",
and intermediate file administration in "aux.c".
.SH THE FILE a.h
.LP
The basic data structures are summarized in the include file "a.h",
along with globally used manifest constants.
LENNAME is the number of characters in a name,
MAXNAME is the longest filename supported,
MAXSTR is the longest <string> that is acceptable,
and NSYM is the number of symbol table roots in the hash table.
.LP
The type LEX is used for any lexemes produced by the token constructor gtok,
while META is any metacharacter returned by gtc.
There are tables of predefined identifiers, for keywords, operators,
and certain instructions, which are kept in sort by identifier to
permit access by binary chop, using scntab.
prename points at the null terminated name, whose first byte is the length
of the string;
pretype is the operator type or value, as appropriate.
.LP
Symbol table entries and terms are all instances of the structure TERM:
next points to the next entry in a symbol table;
ty is the type as in PRETAB;
val is the value of the symbol;
base points to the term which provides the base of relocation for
the symbol value;
and nm is the identifier for a symbol entry.
Legal values of base are cobase for text relative, dabase for data relative,
the symbol entry itself for undefined, or NULL
for absolute symbols.
.LP
Literals require, in addition to the basic TERM fields, a pointer to
a symbol table entry which can be used as a forward reference until
the literal address is determined.
The structure LIT provides this extra pointer.
.LP
All terms, i.e. operands in an expression tree, have the ISTERM bit set
in their ty field;
similarly, all binary operators have BINOP set and all unary operators
have UNOP set.
Some operators may serve as both unary and binary,
in which case both bits are set.
If a symbol is published, via .globl for example, then PUBF is set.
DEFF is set when the symbol is defined, whereas TDEF is set when
a symbol is referenced before being defined, and some commitment
must be made to the type of its eventual definition.
TMASK selects those ty bits that are copied on a definition.
Finally, INDF is set in all types that are indirect addressing references,
either on some register or on a two byte memory address.
.LP
The various lexemes are assigned small integer values with reasonably
mnemonic names, such as PLUSC for "+^" and PUBLIC for "public".
These are grouped as punctuation, operators, and terms.
Still another group of "metatokens" match whole classes of terms or operators;
these occur only in the code tables for operators.
Similarly, names are assigned to the handful of commands passed from
various functions to putcode in aux.c to build the intermediate file.
.SH THE FILE amain.c
.LP
amain.c contains the startup code main(), which deals with file opening
and closing and which contains the primary syntax driver loop.
It also contains the tables of predefined entities and the nontrivial
routine gterm(), which nibbles off a term in the left to right scan of
an input line.
This is the origin of all expression TERMs and the place where parentheses
and unary operators are taken care of.
The logic is fragile.
.LP
main() performs more obvious functions.
Three FIO control buffers are allocated;
in each pass one is used for input and two for output.
All object file output is generated by the call to putftr().
All parsing of input is initiated in the loop on input files;
its primary concern is distinguishing constants and strings from
already evaluated "expressions", which result in instruction sequences
being generated.
.LP
The remaining routines are straightforward:
getal() collects an identifier and, if it can't be located in the
predefined tables, hashes to one of NSYM tables for a linear scan;
undefined symbols are always added to the table.
.LP
getop() looks first for three-character operators, backing off a character
at a time until a match is found, or an illegal operator detected.
gexpr() consumes the operator-operand tails of an expression sequence,
dealing separately with the magic of string concatenation.
gstring() does the dirty work for this.
.LP
hash() simply sums the identifier bytes modulo NSYM;
no studies have been performed to see if this is a good idea.
opname() performs the inverse mapping of operators to names, for
prettier error messages.
tclose() is registered with onexit(), and all interrupts force an early
exit() call, so the temporary files are reliably removed.
.SH THE FILE amake.c
.LP
amake.c consists of lexical analysis routines and a modicum of parsing.
gchar() and bchar() give and take characters, which are read a block
at a time using the standard getc() mechanism.
addsym() and scntab() perform obvious symbol administration,
and cherr(), error(), and nmerr() provide all diagnostic printout.
.LP
bmatch() is called by dobin() in asm.c to match each operand of a binary
operator against the appropriate code table metatoken;
it is probably misfiled.
dosub() performs the nearest thing to compile time arithmetic in the
assembler; it permits the addition of constants to fairly safe terms.
Note that the IX and IY hooks for Z80 code generation are present here,
but are by no means implemented.
dounop() performs one of the handful of unary operators defined in the
language.
.LP
Serious lexical analysis is carried out by the token builder gtok(),
which uses the auxiliary functions gchar(), getesc(), isal(), isdig(),
and tolow().
The language is contrived to avoid the need to push back tokens;
so each is consumed as delivered.
.SH THE FILE asm.c
.LP
asm.c contains the tables of operator operand pairs legal for code
generation, the dobin() program that interprets them, and the dolit()
program for administering the literal pool.
The pool is emitted by putftr(), which also invokes the second pass
that writes the final object file by calling relout() in aux.c.
It also contains some fairly standard operations such as define(),
putbyte(), and putsp().
.LP
dobin() identifies the appropriate table to scan, calling on bmatch()
to check operand classes, then obeys the corresponding format to emit
the code.
Operands are given a value, according to class,
by putval(), which is misnamed since it only returns the value to put.
All output eventually funnels through putbyte, which makes data writing
calls to the intermediate file writer putcode in aux.c.
.SH THE FILE aux.c
.LP
aux.c performs all operations connected with the temporary intermediate files.
All output to these files funnels through putcode(), and all input comes
through relseg(), which is called for each file by relout(), the object
file builder.
.LP
putcode() maintains a buffer each for the text and data segments,
collecting bytes that require no relocation until a buffer is full,
a relocatable word is encountered, or the end of source input is encountered.
drain() ensures that these unrelocated strings are put out as needed,
using the standard putl() and putc() mechanism to buffer output to the
temporary files.
Relocatable items are indicated by a nonzero base, which means that the
first two bytes in the segment buffer must have the value of the base symbol
added to them.
.LP
The object file is written as two streams, each separately buffered,
one for header, text, and data bytes, the other for symbol table,
and text and data relocation bits.
relout() oversees these operations, first allocating symbol numbers
to all undefined symbols and counting the number of symbols to be emitted.
Note that undefined symbols are placed first in the object file, to take
maximum advantage of short encoding for low symbol numbers in the relocation
byte stream.
Note that the two bases have their values contrived so that text and data
are relocated to follow each other in memory.
External symbols are given values four too high,
to be consistent with the relocation byte encoding.
.LP
relseg() performs this final relocation, relocation bit encoding, and
symbol number mapping.
It reads absolute byte strings and relocation items from each intermediate
file and emits both code and relocation bits in parallel by calls on
relby() and relwd().
.LP
relby() buffers all output to the object file, performing lseek() and
write() calls only when necessary and a block at a time whenever possible.
Note that it religiously puts out the bytes of a word in canonical
Intel 8080 order, regardless of host machine;
thus as80 should work properly in any C environment.
